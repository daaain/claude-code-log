#!/usr/bin/env python3
"""Convert Claude transcript JSONL files to HTML."""

import json
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime


def extract_text_content(content: Any) -> str:
    """Extract text content from Claude message content structure."""
    if isinstance(content, list):
        text_parts = []
        for item in content:
            if isinstance(item, dict):
                if item.get("type") == "text":
                    text_parts.append(item.get("text", ""))
                # Skip tool_use and tool_result items since we only want user messages
        return "\n".join(text_parts)
    elif isinstance(content, dict):
        if content.get("type") == "text":
            return content.get("text", "")
    return str(content) if content else ""


def format_timestamp(timestamp_str: str) -> str:
    """Format ISO timestamp for display."""
    try:
        dt = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    except (ValueError, AttributeError):
        return timestamp_str


def load_transcript(jsonl_path: Path) -> List[Dict[str, Any]]:
    """Load and parse JSONL transcript file."""
    messages = []
    with open(jsonl_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line:
                try:
                    entry = json.loads(line)
                    if entry.get("type") in ["user", "assistant"]:
                        # Add source file info for session tracking
                        entry["_source_file"] = jsonl_path.stem
                        messages.append(entry)
                except json.JSONDecodeError:
                    continue
    return messages


def load_directory_transcripts(directory_path: Path) -> List[Dict[str, Any]]:
    """Load all JSONL transcript files from a directory and combine them."""
    all_messages = []
    
    # Find all .jsonl files
    jsonl_files = list(directory_path.glob("*.jsonl"))
    
    for jsonl_file in jsonl_files:
        messages = load_transcript(jsonl_file)
        all_messages.extend(messages)
    
    # Sort all messages chronologically
    all_messages.sort(key=lambda x: x.get("timestamp", ""))
    
    return all_messages


def is_system_message(text_content: str, message_content: dict) -> bool:
    """Check if a message is a system message that should be filtered out."""
    system_message_patterns = [
        "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
        "[Request interrupted by user for tool use]"
    ]
    
    # Check for command messages with <command-name> and <command-message> tags
    if "<command-name>" in text_content and "<command-message>" in text_content:
        return True
    
    # Check for command output messages with <local-command-stdout> tags
    if "<local-command-stdout>" in text_content:
        return True
    
    # Check for tool result messages - these have tool_use_id and type="tool_result"
    if isinstance(message_content, dict) and "content" in message_content:
        content = message_content["content"]
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict) and item.get("type") == "tool_result":
                    return True
    
    return any(pattern in text_content for pattern in system_message_patterns)


def generate_html(messages: List[Dict[str, Any]], title: Optional[str] = None) -> str:
    """Generate HTML from transcript messages."""
    if not title:
        title = "Claude Transcript"
    
    html_parts = [
        "<!DOCTYPE html>",
        "<html lang='en'>",
        "<head>",
        "    <meta charset='UTF-8'>",
        "    <meta name='viewport' content='width=device-width, initial-scale=1.0'>",
        f"    <title>{title}</title>",
        "    <style>",
        "        body {",
        "            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', 'Ubuntu Mono', 'Cascadia Code', 'Menlo', 'Consolas', monospace;",
        "            line-height: 1.5;",
        "            max-width: 1200px;",
        "            margin: 0 auto;",
        "            padding: 10px;",
        "            background-color: #fafafa;",
        "            color: #333;",
        "        }",
        "        .message {",
        "            margin-bottom: 12px;",
        "            padding: 12px;",
        "            border-radius: 6px;",
        "            border-left: 3px solid;",
        "        }",
        "        .session-divider {",
        "            margin: 30px 0;",
        "            padding: 8px 0;",
        "            border-top: 2px solid #ddd;",
        "            text-align: center;",
        "            font-weight: 600;",
        "            color: #666;",
        "            font-size: 0.9em;",
        "        }",
        "        .user {",
        "            background-color: #e3f2fd;",
        "            border-left-color: #2196f3;",
        "        }",
        "        .assistant {",
        "            background-color: #f3e5f5;",
        "            border-left-color: #9c27b0;",
        "        }",
        "        .duplicate-collapsed {",
        "            background-color: #fff3cd;",
        "            border-left-color: #ffc107;",
        "            opacity: 0.7;",
        "        }",
        "        .header {",
        "            font-weight: 600;",
        "            margin-bottom: 8px;",
        "            display: flex;",
        "            justify-content: space-between;",
        "            align-items: center;",
        "        }",
        "        .timestamp {",
        "            font-size: 0.85em;",
        "            color: #666;",
        "            font-weight: normal;",
        "        }",
        "        .content {",
        "            white-space: pre-wrap;",
        "            word-wrap: break-word;",
        "        }",
        "        .duplicate-note {",
        "            font-style: italic;",
        "            color: #856404;",
        "            font-size: 0.9em;",
        "            margin-top: 8px;",
        "        }",
        "        h1 {",
        "            text-align: center;",
        "            color: #2c3e50;",
        "            margin-bottom: 20px;",
        "            font-size: 1.8em;",
        "        }",
        "        code {",
        "            background-color: #f5f5f5;",
        "            padding: 2px 4px;",
        "            border-radius: 3px;",
        "            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;",
        "        }",
        "        pre {",
        "            background-color: #f5f5f5;",
        "            padding: 10px;",
        "            border-radius: 5px;",
        "            overflow-x: auto;",
        "        }",
        "    </style>",
        "</head>",
        "<body>",
        f"    <h1>{title}</h1>",
    ]
    
    current_session = None
    last_message_content = None
    
    for message in messages:
        message_type = message.get("type", "unknown")
        
        # Only show user messages by default
        if message_type != "user":
            continue
            
        # Extract message content first to check for duplicates
        message_content = message.get("message", {})
        if isinstance(message_content, dict):
            content = message_content.get("content", "")
        else:
            content = message_content
        
        text_content = extract_text_content(content)
        if not text_content.strip():
            continue
            
        # Filter out system messages
        if is_system_message(text_content, message_content):
            continue
        
        # Check if we're in a new session
        source_file = message.get("_source_file", "unknown")
        is_new_session = current_session != source_file
        
        # Check for duplicate message at session boundary
        is_duplicate = (is_new_session and 
                       last_message_content is not None and 
                       text_content.strip() == last_message_content.strip())
        
        if is_new_session:
            if current_session is not None:  # Don't add divider before first session
                html_parts.append(f"    <div class='session-divider'>Session: {source_file}</div>")
            else:
                html_parts.append(f"    <div class='session-divider'>Session: {source_file}</div>")
            current_session = source_file
            
        timestamp = message.get("timestamp", "")
        formatted_timestamp = format_timestamp(timestamp) if timestamp else ""
        
        # Determine CSS class and content based on duplicate status
        css_class = f"{message_type}"
        content_html = text_content
        
        if is_duplicate:
            css_class += " duplicate-collapsed"
            content_html = f"<div class='duplicate-note'>(Duplicate from previous session - collapsed)</div>"
        
        html_parts.extend([
            f"    <div class='message {css_class}'>",
            "        <div class='header'>",
            f"            <span>{message_type.title()}</span>",
            f"            <span class='timestamp'>{formatted_timestamp}</span>",
            "        </div>",
            f"        <div class='content'>{content_html}</div>",
            "    </div>",
        ])
        
        # Update last message content for duplicate detection
        last_message_content = text_content
    
    html_parts.extend([
        "</body>",
        "</html>"
    ])
    
    return "\n".join(html_parts)


def convert_jsonl_to_html(input_path: Path, output_path: Optional[Path] = None) -> Path:
    """Convert JSONL transcript(s) to HTML file."""
    if not input_path.exists():
        raise FileNotFoundError(f"Input path not found: {input_path}")
    
    if input_path.is_file():
        # Single file mode
        if output_path is None:
            output_path = input_path.with_suffix('.html')
        messages = load_transcript(input_path)
        title = f"Claude Transcript - {input_path.stem}"
    else:
        # Directory mode
        if output_path is None:
            output_path = input_path / "combined_transcripts.html"
        messages = load_directory_transcripts(input_path)
        title = f"Claude Transcripts - {input_path.name}"
    
    html_content = generate_html(messages, title)
    output_path.write_text(html_content, encoding='utf-8')
    return output_path